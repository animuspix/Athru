#include "Boxecule.h"
#include "ShaderCentre.h"

ShaderCentre::ShaderCentre(ID3D11Device* device, HWND windowHandle, Logger* logger)
{
	// Long integer used to store success/failure for different DirectX operations
	HRESULT result;

	// DirectX struct used to hold errors generated by failed shader operations
	ID3D10Blob* errorMessage;

	// Compile the shaders available to the shader centre

	// Load the colorizer from the compiled shader generated by VS
	ID3D10Blob* vertPlotterBuffer;
	result = D3DReadFileToBlob(L"VertPlotter.cso", &vertPlotterBuffer);

	// Load the colorizer from the compiled shader generated by VS
	ID3D10Blob* colorizerBuffer;
	result = D3DReadFileToBlob(L"Colorizer.cso", &colorizerBuffer);

	// Instantiate the shaders available to the shader centre

	// Instantiate the vertex plotter from the buffer filled during compilation
	result = device->CreateVertexShader(vertPlotterBuffer->GetBufferPointer(), vertPlotterBuffer->GetBufferSize(), NULL, &vertPlotter);
	
	// Instantiate the colorizer from the buffer filled during compilation
	result = device->CreatePixelShader(colorizerBuffer->GetBufferPointer(), colorizerBuffer->GetBufferSize(), NULL, &colorizer);

	// Setup the vertex input layout description
	D3D11_INPUT_ELEMENT_DESC polygonLayout[2];

	// Layout the first part of each vertex (associated with position)
	polygonLayout[0].SemanticName = "POSITION";
	polygonLayout[0].SemanticIndex = 0;
	polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	polygonLayout[0].InputSlot = 0;
	polygonLayout[0].AlignedByteOffset = 0;
	polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[0].InstanceDataStepRate = 0;

	// Layout the second part of each vertex (associated with color)
	polygonLayout[1].SemanticName = "COLOR";
	polygonLayout[1].SemanticIndex = 0;
	polygonLayout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	polygonLayout[1].InputSlot = 0;
	polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[1].InstanceDataStepRate = 0;

	// Instantiate the vertex input layout with the description created above,
	// and store the result in [inputLayout]
	result = device->CreateInputLayout(polygonLayout, 2, vertPlotterBuffer->GetBufferPointer(),
									   vertPlotterBuffer->GetBufferSize(), &inputLayout);

	// We aren't going to use them again, so release the shader buffers here
	vertPlotterBuffer->Release();
	vertPlotterBuffer = 0;

	colorizerBuffer->Release();
	colorizerBuffer = 0;

	// Set up the description of the matrix buffer (Spatializer)
	D3D11_BUFFER_DESC matrixBufferDesc;
	matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	matrixBufferDesc.ByteWidth = sizeof(Spatializer);
	matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	matrixBufferDesc.MiscFlags = 0;
	matrixBufferDesc.StructureByteStride = 0;

	// Instantiate a pointer to the matrix buffer within [vertPlotter] so we can access it from
	// within [this]
	result = device->CreateBuffer(&matrixBufferDesc, NULL, &matrixBuffer);

	assert(SUCCEEDED(result));
}

ShaderCentre::~ShaderCentre()
{
	// Release the matrix constant buffer
	matrixBuffer->Release();
	matrixBuffer = 0;

	// Release the layout
	inputLayout->Release();
	inputLayout = 0;

	// Release [colorizer]
	colorizer->Release();
	colorizer = 0;

	// Release [vertPlotter]
	vertPlotter->Release();
	vertPlotter = 0;
}

void ShaderCentre::Render(ID3D11DeviceContext* deviceContext, 
						  DirectX::XMMATRIX world, DirectX::XMMATRIX view, DirectX::XMMATRIX projection)
{
	// Set shader parameters

	// Transpose each XMMATRIX so it can easily work with the shaders (DirectX is normally row-major; HLSL shaders are column-major)
	world = DirectX::XMMatrixTranspose(world);
	view = DirectX::XMMatrixTranspose(view);
	projection = DirectX::XMMatrixTranspose(projection);

	// Long integer used to track success/failure for DirectX operations
	HRESULT result;

	D3D11_MAPPED_SUBRESOURCE mappedResource;
	Spatializer* dataPtr;
	unsigned int bufferNumber;

	// Lock the vertex shader's cbuffer
	result = deviceContext->Map(matrixBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);

	// Get a pointer to the data in the cbuffer
	dataPtr = (Spatializer*)mappedResource.pData;

	// Copy the matrices into the cbuffer.
	dataPtr->world = world;
	dataPtr->view = view;
	dataPtr->projection = projection;

	// Unlock the cbuffer
	deviceContext->Unmap(matrixBuffer, 0);

	// Set the position of the cbuffer in the vertex shader
	// (kinda like accessing an "in" variable)
	bufferNumber = 0;

	// Transfer the updated world/view/projection matrices into the cbuffer within
	// the vertex shader
	deviceContext->VSSetConstantBuffers(bufferNumber, 1, &matrixBuffer);

	// Test if anything broke when we set the shader parameters :P
	assert(SUCCEEDED(result));

	// Begin rendering to the screen (!!!)

	// Set the vertex input layout.
	deviceContext->IASetInputLayout(inputLayout);

	// Set the vertex and pixel shaders that will be used to render the Boxecule
	deviceContext->VSSetShader(vertPlotter, NULL, 0);
	deviceContext->PSSetShader(colorizer, NULL, 0);

	// Render the Boxecule
	deviceContext->DrawIndexed(BOXECULE_VERT_COUNT, 0, 0);
}																  
