
#include "GenericUtility.hlsli"

// A small CPU-updatable block of display constants
cbuffer DisplayInfo
{
    float4 display; // Carries width in [x], height in [y], area in [z], AA sampling rate in [w]
};

// A 2D texture fitting the window size (i.e. the display texture);
// carries the multi-frame image data generated by [SceneVis]
Texture2D<float4> displayTex : register(t0);

// A texture sampler; needed to cleanly sample values from the
// display texture in [t0]
SamplerState wrapSampler : register(s0);

struct Pixel
{
    float4 pos : SV_POSITION0;
    float2 texCoord : TEXCOORD0;
};

// Small convenience function for squaring long expressions
float3 Sqr(float3 expr)
{
    return expr * expr;
}

// Conservative filter function for persistent noise that doesn't
// fade under multisampling; preserves ray-traced grain while
// removing fireflies and dark speckling
// Standard deviation definition from:
// https://en.wikipedia.org/wiki/Standard_deviation#Estimation
// using the uncorrected per-sample variation
float4 Denoise(float4 localPx,
               float2 uv)
{
    // Outliers will lie at least ~three standard deviations beyond the local mean
    // [3.2] works well as a compromise value (essentially no edge distortion, effective
    // noise mitigation) but can't always remove severe highlights/speckles; stronger
    // treatments may need variance-guiding to generate appropriate thresholds for
    // arbitrary surface images
    const float sdFac = 3.2f;

    // Denoising will operate over a 25-pixel kernel (two rings)
    const uint krnRad = 5.0f;
    uint krnArea = krnRad * krnRad;

    // Cache uv step size, starting uv-index before sampling the filter kernel
    float2 uvStep = 1.0f.xx / display.xy;
    float2 minKrnUV = uv - (uvStep * ((float)(krnRad - 1) / 2.0f)).xx;

    // Sample + cache the filter kernel; also cache local mean + standard deviation
    // Possibly linearizable in SM6...
    float2x3 stats = float2x3(0.0f.xxx, 0.0f.xxx); // Mean in [0][rgb], standard deviation in [1][rgb]
    float3 krn[25];
    for (uint i = 0; i < krnArea; i += 1) // Evaluate the mean (unsure how to compute SD inline with the mean, separating each for now)
    {
        float2 currStep = minKrnUV + (float2(i % krnRad,
                                             i / krnRad) * uvStep);
        float3 currSample = displayTex.Sample(wrapSampler, currStep).rgb;
        krn[i] = currSample; // Cache the current sample value
        stats[0] += currSample / krnArea; // Update local mean
    }
    for (uint j = 0; j < krnArea; j += 1) // Evaluate standard deviation
    {
        stats[1] += Sqr(krn[j].rgb - stats[0]) / krnArea;
    }
    stats[1] = sqrt(stats[1]); // SD definition involves a square-root over the series, apply that here

    // Check whether [localPx] is an outlier, and replace the centroid at [uv] with the mean if so
    // This is equivalent to a box-filter; cleaner blurs (like e.g. a Gaussian) would probably be
    // better
    if (abs(length(localPx.rgb) - length(stats[0])) >= length(stats[1] * sdFac)) // Check whether the local pixel is at least [sdFac] standard deviations above the mean
                                                                                 // Denoiser only cares about brightness for now, not hue
    {
        return float4(stats[0], 1.0f);
    }
    else
    {
        return localPx;
    }
}

float4 main(Pixel pixIn) : SV_TARGET
{
    // Output denoised color for the current pixel from [displayTex]
    return Denoise(displayTex.Sample(wrapSampler, pixIn.texCoord),
                   pixIn.texCoord);
}